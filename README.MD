# ProgramaÃ§Ã£o Orientada a Objetos (POO) ðŸš€

Este repositÃ³rio Ã© dedicado ao meu aprendizado sobre **ProgramaÃ§Ã£o Orientada a Objetos (POO)**. Aqui, explico de forma simples e intuitiva os principais conceitos da POO com exemplos prÃ¡ticos em **Java**, utilizando apenas **animais de estimaÃ§Ã£o** como exemplo para facilitar o entendimento.

# Classes e Objetos

Em **POO** (ProgramaÃ§Ã£o Orientada a Objetos), classes sÃ£o modelos que definem as caracterÃ­sticas (**estado**) e comportamentos (**mÃ©todos**) de um objeto. Os objetos por sua vez sÃ£o instÃ¢ncias dessas classes, ou seja, representam entidades especÃ­ficas baseadas no modelo definido pela classe.

### O que sÃ£o **estados** e **mÃ©todos** de um objeto?

- **Estado**: Representa os atributos ou dados do objeto. SÃ£o as informaÃ§Ãµes que descrevem o objeto em um determinado momento.
- **MÃ©todos**: Representa as aÃ§Ãµes ou mÃ©todos que o objeto pode executar, definindo como ele interage com outros objetos ou altera seu prÃ³prio estado.

### Analogias para facilitar o entendimento

Pense em uma classe como uma **receita de bolo**. A receita contÃ©m todos os ingredientes e instruÃ§Ãµes necessÃ¡rias para fazer um bolo, mas por si sÃ³ nÃ£o Ã© um bolo real. JÃ¡ o bolo pronto Ã© um **objeto**, ou seja, uma instÃ¢ncia concreta daquela receita.

Outro exemplo: Imagine uma classe **"Animal"**. Essa classe define que todo animal tem um **nome** e uma **idade** (estado) e pode realizar aÃ§Ãµes como **exibir suas informaÃ§Ãµes** (mÃ©todo).

Se tivermos um cachorro chamado **"Rex"**, ele seria um objeto da classe "Animal". Ele tem seu prÃ³prio nome e idade (estado) e pode realizar aÃ§Ãµes definidas na classe, como exibir suas informaÃ§Ãµes (mÃ©todo). Outro cachorro chamado **"Bolt"** seria outro objeto da mesma classe, mas com um estado diferente.

### ðŸ“Œ Exemplo TÃ©cnico:

```java
// DefiniÃ§Ã£o da classe Animal
class Animal {
    String nome; // Estado: nome do animal
    int idade;  // Estado: idade do animal

    // MÃ©todo para exibir informaÃ§Ãµes do animal
    void exibirInformacoes() {
        System.out.println("Nome: " + nome + ", Idade: " + idade + " anos");
    }
}

// Classe principal
public class Main {
    public static void main(String[] args) {
        // Criando um objeto da classe Animal
        Animal pet = new Animal(); // InstÃ¢ncia da classe "Animal"
        
        // Definindo o estado do objeto
        pet.nome = "Rex";
        pet.idade = 3;
        
        // Executando um mÃ©todo do objeto
        pet.exibirInformacoes();
    }
}
```

### ðŸ” ExplicaÃ§Ã£o do CÃ³digo:

1. Criamos a classe `Animal` com dois atributos: `nome` e `idade` (**estado**).
2. Definimos um mÃ©todo `exibirInformacoes()`, que exibe o nome e a idade do animal.
3. No mÃ©todo `main`, instanciamos um objeto `pet` da classe `Animal`.
4. AtribuÃ­mos valores ao estado do objeto (`nome` e `idade`).
5. Chamamos o mÃ©todo `exibirInformacoes()`, que imprime os detalhes do animal.

### ðŸ“Œ SaÃ­da do CÃ³digo:

```
Nome: Rex, Idade: 3 anos
```

Dessa forma, podemos entender claramente que os objetos tÃªm um **estado** (valores especÃ­ficos dos atributos) e um **comportamento** (mÃ©todos que definem suas aÃ§Ãµes).




---
# Encapsulamento

Em **POO** **encapsulamento** Ã© um dos princÃ­pios fundamentais que protege os dados de um objeto, restringindo o acesso direto aos seus atributos e permitindo que sejam manipulados apenas atravÃ©s de mÃ©todos controlados.

Isso ajuda a manter a integridade e seguranÃ§a dos dados, evitando modificaÃ§Ãµes indevidas.

## ðŸ” O que Ã© **Encapsulamento**?

O encapsulamento Ã© a prÃ¡tica de **esconder detalhes internos** de um objeto e fornecer uma interface segura para interaÃ§Ã£o. Isso Ã© feito definindo os atributos como **privados** e fornecendo mÃ©todos pÃºblicos para acessÃ¡-los e modificÃ¡-los (**getters** e **setters**).

### ðŸ“Œ BenefÃ­cios do Encapsulamento:
- Protege os dados de acessos indevidos.
- MantÃ©m a integridade do objeto.
- Facilita a manutenÃ§Ã£o e modificaÃ§Ã£o do cÃ³digo.
- Permite controlar as regras de acesso e modificaÃ§Ã£o dos atributos.

### ðŸ“– Analogias para entender melhor

Imagine um **cofre** onde vocÃª guarda dinheiro. O dinheiro (dado) estÃ¡ protegido dentro do cofre (objeto), e vocÃª sÃ³ pode acessÃ¡-lo usando a chave correta (mÃ©todos). NinguÃ©m pode pegar o dinheiro diretamente sem seguir as regras do cofre.

Outro exemplo: pense em um **controle remoto**. VocÃª pode aumentar ou diminuir o volume da TV pressionando botÃµes (mÃ©todos), mas nÃ£o pode modificar diretamente os circuitos internos da TV (dados protegidos).

## ðŸ“Œ Exemplo TÃ©cnico:

```java
// DefiniÃ§Ã£o da classe ContaBancaria
class ContaBancaria {
    // Atributos privados (Encapsulamento)
    private String titular;
    private double saldo;

    // Construtor para inicializar os valores
    public ContaBancaria(String titular, double saldoInicial) {
        this.titular = titular;
        this.saldo = saldoInicial;
    }

    // MÃ©todo getter para obter o saldo
    public double getSaldo() {
        return saldo;
    }

    // MÃ©todo para depositar dinheiro (modifica saldo com regras)
    public void depositar(double valor) {
        if (valor > 0) {
            saldo += valor;
            System.out.println("DepÃ³sito de R$" + valor + " realizado com sucesso.");
        } else {
            System.out.println("Valor de depÃ³sito invÃ¡lido!");
        }
    }

    // MÃ©todo para sacar dinheiro (modifica saldo com validaÃ§Ã£o)
    public void sacar(double valor) {
        if (valor > 0 && valor <= saldo) {
            saldo -= valor;
            System.out.println("Saque de R$" + valor + " realizado com sucesso.");
        } else {
            System.out.println("Saldo insuficiente ou valor invÃ¡lido!");
        }
    }
}

// Classe principal para testar o encapsulamento
public class Main {
    public static void main(String[] args) {
        // Criando um objeto da classe ContaBancaria
        ContaBancaria minhaConta = new ContaBancaria("JoÃ£o", 1000.00);
        
        // Consultando o saldo via mÃ©todo getter
        System.out.println("Saldo atual: R$" + minhaConta.getSaldo());
        
        // Tentando depositar um valor
        minhaConta.depositar(500.00);
        System.out.println("Saldo atual: R$" + minhaConta.getSaldo());
        
        // Tentando sacar um valor
        minhaConta.sacar(300.00);
        System.out.println("Saldo atual: R$" + minhaConta.getSaldo());
        
        // Tentativa de saque maior que o saldo
        minhaConta.sacar(2000.00);
    }
}
```

### ðŸ” ExplicaÃ§Ã£o do CÃ³digo:
1. Criamos a classe `ContaBancaria` com os atributos `titular` e `saldo` **privados**, garantindo que sÃ³ possam ser acessados por mÃ©todos especÃ­ficos.
2. Implementamos um **construtor** para inicializar a conta com um saldo inicial.
3. Criamos um **getter** (`getSaldo()`) para permitir a consulta do saldo.
4. Criamos um mÃ©todo `depositar(double valor)`, que adiciona dinheiro ao saldo, mas apenas se o valor for positivo.
5. Criamos um mÃ©todo `sacar(double valor)`, que permite retirar dinheiro da conta **apenas se houver saldo suficiente**.
6. No `main`, instanciamos um objeto `minhaConta`, realizamos depÃ³sitos, saques e tentamos fazer um saque maior que o saldo disponÃ­vel para ver como o encapsulamento protege os dados.

### ðŸ“Œ SaÃ­da do CÃ³digo:

```
Saldo atual: R$1000.0
DepÃ³sito de R$500.0 realizado com sucesso.
Saldo atual: R$1500.0
Saque de R$300.0 realizado com sucesso.
Saldo atual: R$1200.0
Saldo insuficiente ou valor invÃ¡lido!
```

### ðŸ”Ž O que aprendemos?
- **Os atributos estÃ£o protegidos** e nÃ£o podem ser modificados diretamente.
- **Os mÃ©todos controlam o acesso aos dados**, garantindo que apenas operaÃ§Ãµes vÃ¡lidas sejam realizadas.
- **O encapsulamento protege a integridade do objeto**, impedindo mudanÃ§as indesejadas nos atributos.

Dessa forma, **o encapsulamento melhora a seguranÃ§a e organizaÃ§Ã£o do cÃ³digo, facilitando a manutenÃ§Ã£o e prevenÃ§Ã£o de erros.** ðŸš€



---
### 3ï¸âƒ£ HeranÃ§a

A **heranÃ§a** permite que uma classe reutilize atributos e mÃ©todos de outra classe, evitando repetiÃ§Ã£o de cÃ³digo.

ðŸ“Œ **Exemplo:** Criamos uma **superclasse "Animal"** e as subclasses **"Cachorro"** e **"Gato"** que herdam dela.

```java
class Animal {
    String nome;
    int idade;
    
    void emitirSom() {
        System.out.println("O animal faz um som.");
    }
}

class Cachorro extends Animal {
    @Override
    void emitirSom() {
        System.out.println("O cachorro late: Au Au!");
    }
}

class Gato extends Animal {
    @Override
    void emitirSom() {
        System.out.println("O gato mia: Miau!");
    }
}

public class Main {
    public static void main(String[] args) {
        Cachorro dog = new Cachorro();
        dog.nome = "Rex";
        dog.idade = 4;
        dog.emitirSom();
        
        Gato cat = new Gato();
        cat.nome = "Mia";
        cat.idade = 2;
        cat.emitirSom();
    }
}
```

ðŸ” **ExplicaÃ§Ã£o:**
- `Cachorro` e `Gato` herdam atributos e mÃ©todos da classe `Animal`.
- Sobrescrevemos o mÃ©todo `emitirSom()` em cada subclasse para personalizar o comportamento.
- Criamos objetos `dog` e `cat` e chamamos seus mÃ©todos.

---
### 4ï¸âƒ£ AbstraÃ§Ã£o

A **abstraÃ§Ã£o** permite definir **o que um objeto faz**, sem expor **como ele faz**.

ðŸ“Œ **Exemplo:** Criamos uma classe abstrata `Animal` com o mÃ©todo abstrato `emitirSom()`, que serÃ¡ implementado nas subclasses `Cachorro` e `Gato`.

```java
abstract class Animal {
    abstract void emitirSom();
}

class Cachorro extends Animal {
    @Override
    void emitirSom() {
        System.out.println("O cachorro late: Au Au!");
    }
}

class Gato extends Animal {
    @Override
    void emitirSom() {
        System.out.println("O gato mia: Miau!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal meuCachorro = new Cachorro();
        meuCachorro.emitirSom();

        Animal meuGato = new Gato();
        meuGato.emitirSom();
    }
}
```

ðŸ” **ExplicaÃ§Ã£o:**
- `Animal` Ã© abstrata e define `emitirSom()`, sem implementaÃ§Ã£o.
- `Cachorro` e `Gato` implementam `emitirSom()` de maneira especÃ­fica.
- Criamos objetos que usam polimorfismo para chamar `emitirSom()`.

---
## ðŸ“¢ ConclusÃ£o

A ProgramaÃ§Ã£o Orientada a Objetos Ã© uma abordagem poderosa para o desenvolvimento de software. Com esses conceitos, podemos escrever **cÃ³digo mais organizado, reutilizÃ¡vel e fÃ¡cil de manter**.

Se vocÃª gostou, â­ este repositÃ³rio no **GitHub**!

