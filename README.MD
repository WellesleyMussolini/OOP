# ProgramaÃ§Ã£o Orientada a Objetos (POO) ğŸš€

Este repositÃ³rio Ã© dedicado ao meu aprendizado sobre **ProgramaÃ§Ã£o Orientada a Objetos (POO)**. Aqui, explico de forma simples e intuitiva os principais conceitos da POO com exemplos prÃ¡ticos em **Java**, utilizando apenas **animais de estimaÃ§Ã£o** como exemplo para facilitar o entendimento.

# Classes e Objetos

Em **POO** (ProgramaÃ§Ã£o Orientada a Objetos), classes sÃ£o modelos que definem as caracterÃ­sticas (**estado**) e comportamentos (**mÃ©todos**) de um objeto. Os objetos por sua vez sÃ£o instÃ¢ncias dessas classes, ou seja, representam entidades especÃ­ficas baseadas no modelo definido pela classe.

### O que sÃ£o **estados** e **mÃ©todos** de um objeto?

- **Estado**: Representa os atributos ou dados do objeto. SÃ£o as informaÃ§Ãµes que descrevem o objeto em um determinado momento.
- **MÃ©todos**: Representa as aÃ§Ãµes ou mÃ©todos que o objeto pode executar, definindo como ele interage com outros objetos ou altera seu prÃ³prio estado.

### Analogias para facilitar o entendimento

Pense em uma classe como uma **receita de bolo**. A receita contÃ©m todos os ingredientes e instruÃ§Ãµes necessÃ¡rias para fazer um bolo, mas por si sÃ³ nÃ£o Ã© um bolo real. JÃ¡ o bolo pronto Ã© um **objeto**, ou seja, uma instÃ¢ncia concreta daquela receita.

Outro exemplo: Imagine uma classe **"Animal"**. Essa classe define que todo animal tem um **nome** e uma **idade** (estado) e pode realizar aÃ§Ãµes como **exibir suas informaÃ§Ãµes** (mÃ©todo).

Se tivermos um cachorro chamado **"Rex"**, ele seria um objeto da classe "Animal". Ele tem seu prÃ³prio nome e idade (estado) e pode realizar aÃ§Ãµes definidas na classe, como exibir suas informaÃ§Ãµes (mÃ©todo). Outro cachorro chamado **"Bolt"** seria outro objeto da mesma classe, mas com um estado diferente.

### ğŸ“Œ Exemplo TÃ©cnico:

```java
// DefiniÃ§Ã£o da classe Animal
class Animal {
    String nome; // Estado: nome do animal
    int idade;  // Estado: idade do animal

    // MÃ©todo para exibir informaÃ§Ãµes do animal
    void exibirInformacoes() {
        System.out.println("Nome: " + nome + ", Idade: " + idade + " anos");
    }
}

// Classe principal
public class Main {
    public static void main(String[] args) {
        // Criando um objeto da classe Animal
        Animal pet = new Animal(); // InstÃ¢ncia da classe "Animal"
        
        // Definindo o estado do objeto
        pet.nome = "Rex";
        pet.idade = 3;
        
        // Executando um mÃ©todo do objeto
        pet.exibirInformacoes();
    }
}
```

### ğŸ” ExplicaÃ§Ã£o do CÃ³digo:

1. Criamos a classe `Animal` com dois atributos: `nome` e `idade` (**estado**).
2. Definimos um mÃ©todo `exibirInformacoes()`, que exibe o nome e a idade do animal.
3. No mÃ©todo `main`, instanciamos um objeto `pet` da classe `Animal`.
4. AtribuÃ­mos valores ao estado do objeto (`nome` e `idade`).
5. Chamamos o mÃ©todo `exibirInformacoes()`, que imprime os detalhes do animal.

### ğŸ“Œ SaÃ­da do CÃ³digo:

```
Nome: Rex, Idade: 3 anos
```

Dessa forma, podemos entender claramente que os objetos tÃªm um **estado** (valores especÃ­ficos dos atributos) e um **comportamento** (mÃ©todos que definem suas aÃ§Ãµes).




---
# Encapsulamento

Em **POO** **encapsulamento** Ã© um dos princÃ­pios fundamentais que protege os dados de um objeto, restringindo o acesso direto aos seus atributos e permitindo que sejam manipulados apenas atravÃ©s de mÃ©todos controlados.

Isso ajuda a manter a integridade e seguranÃ§a dos dados, evitando modificaÃ§Ãµes indevidas.

## ğŸ” O que Ã© **Encapsulamento**?

O encapsulamento Ã© a prÃ¡tica de **esconder detalhes internos** de um objeto e fornecer uma interface segura para interaÃ§Ã£o. Isso Ã© feito definindo os atributos como **privados** e fornecendo mÃ©todos pÃºblicos para acessÃ¡-los e modificÃ¡-los (**getters** e **setters**).

### ğŸ“Œ BenefÃ­cios do Encapsulamento:
- Protege os dados de acessos indevidos.
- MantÃ©m a integridade do objeto.
- Facilita a manutenÃ§Ã£o e modificaÃ§Ã£o do cÃ³digo.
- Permite controlar as regras de acesso e modificaÃ§Ã£o dos atributos.

### ğŸ“– Analogias para entender melhor

Imagine um **cofre** onde vocÃª guarda dinheiro. O dinheiro (dado) estÃ¡ protegido dentro do cofre (objeto), e vocÃª sÃ³ pode acessÃ¡-lo usando a chave correta (mÃ©todos). NinguÃ©m pode pegar o dinheiro diretamente sem seguir as regras do cofre.

Outro exemplo: pense em um **controle remoto**. VocÃª pode aumentar ou diminuir o volume da TV pressionando botÃµes (mÃ©todos), mas nÃ£o pode modificar diretamente os circuitos internos da TV (dados protegidos).

Aqui estÃ¡ o texto formatado para o seu README:  

---

### ğŸ“Œ Exemplo TÃ©cnico: Encapsulamento em um Sistema de Controle de Temperatura  

```java
// Classe ControladorDeTemperatura
class ControladorDeTemperatura {
    // Atributo privado (Encapsulamento)
    private double temperatura;

    // Construtor para definir uma temperatura inicial
    public ControladorDeTemperatura(double temperaturaInicial) {
        this.temperatura = temperaturaInicial;
    }

    // MÃ©todo getter para obter a temperatura atual
    public double getTemperatura() {
        return temperatura;
    }

    // MÃ©todo setter para definir a temperatura (com validaÃ§Ã£o)
    public void setTemperatura(double novaTemperatura) {
        if (novaTemperatura >= -50 && novaTemperatura <= 100) {
            this.temperatura = novaTemperatura;
            System.out.println("Temperatura ajustada para: " + novaTemperatura + "Â°C");
        } else {
            System.out.println("Temperatura fora do limite permitido!");
        }
    }
}

// Classe principal para testar o encapsulamento
public class Main {
    public static void main(String[] args) {
        // Criando um objeto da classe ControladorDeTemperatura
        ControladorDeTemperatura sensor = new ControladorDeTemperatura(22.5);
        
        // Consultando a temperatura atual
        System.out.println("Temperatura atual: " + sensor.getTemperatura() + "Â°C");
        
        // Ajustando a temperatura para um valor vÃ¡lido
        sensor.setTemperatura(30.0);
        
        // Tentando definir uma temperatura invÃ¡lida
        sensor.setTemperatura(150.0);
    }
}
```

## ğŸ” ExplicaÃ§Ã£o do CÃ³digo  

1. Criamos a classe `ControladorDeTemperatura` com um atributo **privado** `temperatura`, impedindo acesso direto a ele.  
2. Criamos um **construtor** para definir um valor inicial de temperatura.  
3. Criamos um **getter** (`getTemperatura()`) para permitir a consulta da temperatura.  
4. Criamos um **setter** (`setTemperatura()`) para alterar a temperatura **com uma validaÃ§Ã£o** que impede valores fora do intervalo permitido (-50Â°C a 100Â°C).  
5. No `main`, criamos um objeto `sensor`, consultamos a temperatura, ajustamos para um valor vÃ¡lido e testamos um valor invÃ¡lido.  

## ğŸ“Œ SaÃ­da do CÃ³digo  

```
Temperatura atual: 22.5Â°C  
Temperatura ajustada para: 30.0Â°C  
Temperatura fora do limite permitido!  
```

## ğŸ” O que aprendemos?  

- **O atributo `temperatura` estÃ¡ encapsulado**, protegendo-o de alteraÃ§Ãµes externas indevidas.  
- **O mÃ©todo `setTemperatura()` garante que sÃ³ valores vÃ¡lidos sejam atribuÃ­dos**, evitando falhas no sistema.  
- **O encapsulamento melhora a seguranÃ§a e controle dos dados**, garantindo que apenas operaÃ§Ãµes seguras sejam realizadas.  

---
Aqui estÃ¡ o texto formatado para o seu README sobre **HeranÃ§a** seguindo o mesmo padrÃ£o:

---

# ğŸ›ï¸ HeranÃ§a

Em **POO**, a **heranÃ§a** Ã© um princÃ­pio que permite que uma classe (subclasse) herde atributos e mÃ©todos de outra classe (superclasse). Isso promove **reutilizaÃ§Ã£o de cÃ³digo** e facilita a organizaÃ§Ã£o e manutenÃ§Ã£o do sistema.

## ğŸ” O que Ã© **HeranÃ§a**?

A heranÃ§a Ã© um mecanismo que permite a criaÃ§Ã£o de novas classes baseadas em classes existentes. A **classe filha** herda atributos e comportamentos da **classe pai**, podendo reutilizÃ¡-los, modificÃ¡-los ou adicionar novos.

### ğŸ“Œ BenefÃ­cios da HeranÃ§a:
- **ReutilizaÃ§Ã£o de cÃ³digo**: evita duplicaÃ§Ã£o de cÃ³digo, tornando o sistema mais eficiente.
- **Facilita a manutenÃ§Ã£o**: mudanÃ§as na superclasse sÃ£o refletidas nas subclasses.
- **Promove hierarquia e organizaÃ§Ã£o**: classes mais genÃ©ricas servem como base para classes mais especÃ­ficas.
- **Permite polimorfismo**: possibilita que objetos da subclasse sejam tratados como objetos da superclasse.

### ğŸ“– Analogias para entender melhor

Imagine um **carro elÃ©trico**. Ele herda caracterÃ­sticas de um **carro comum** (rodas, volante, portas), mas pode ter novas funcionalidades, como um motor elÃ©trico.

Outro exemplo: pense em uma **Ã¡rvore genealÃ³gica**. Uma pessoa herda caracterÃ­sticas dos seus pais, mas tambÃ©m pode ter atributos Ãºnicos que a diferenciam.

---

### ğŸ“Œ Exemplo TÃ©cnico: HeranÃ§a em um Sistema de Pets  

```java
// Classe base (superclasse)
class Animal {
    protected String nome;
    protected int idade;

    public Animal(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    public void exibirDados() {
        System.out.println("Nome: " + nome);
        System.out.println("Idade: " + idade + " anos");
    }
}

// Classe derivada (subclasse) que herda de Animal
class Cachorro extends Animal {
    private String raca;

    public Cachorro(String nome, int idade, String raca) {
        super(nome, idade); // Chama o construtor da superclasse
        this.raca = raca;
    }

    @Override
    public void exibirDados() {
        super.exibirDados(); // Reutiliza mÃ©todo da superclasse
        System.out.println("RaÃ§a: " + raca);
    }
}

// Classe principal para testar a heranÃ§a
public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal("Bicho", 5);
        Cachorro cachorro = new Cachorro("Rex", 3, "Labrador");

        System.out.println("Dados do Animal:");
        animal.exibirDados();
        
        System.out.println("\nDados do Cachorro:");
        cachorro.exibirDados();
    }
}
```

## ğŸ” ExplicaÃ§Ã£o do CÃ³digo  

1. Criamos a **classe `Animal`** (superclasse), que contÃ©m atributos comuns como `nome` e `idade`.
2. Criamos a **classe `Cachorro`** (subclasse), que **herda** de `Animal` e adiciona um novo atributo `raca`.
3. No **construtor da subclasse**, usamos `super(nome, idade)` para chamar o construtor da superclasse.
4. Sobrescrevemos (`@Override`) o mÃ©todo `exibirDados()` na subclasse para incluir a raÃ§a do cachorro.
5. No `main`, criamos um objeto da superclasse (`Animal`) e um da subclasse (`Cachorro`) e chamamos `exibirDados()` para ambos.

## ğŸ‘‰ SaÃ­da do CÃ³digo  

```
Dados do Animal:
Nome: Bicho
Idade: 5 anos

Dados do Cachorro:
Nome: Rex
Idade: 3 anos
RaÃ§a: Labrador
```

## ğŸ” O que aprendemos?  

- **A classe `Cachorro` herda os atributos e mÃ©todos de `Animal`**, reutilizando cÃ³digo.  
- **A palavra-chave `super` permite acessar mÃ©todos da superclasse** dentro da subclasse.  
- **Podemos sobrescrever mÃ©todos (`@Override`) para personalizar o comportamento da subclasse**.  
- **HeranÃ§a permite criar hierarquias organizadas e reutilizar cÃ³digo eficientemente**. ğŸš€



---
### 4ï¸âƒ£ AbstraÃ§Ã£o

A **abstraÃ§Ã£o** permite definir **o que um objeto faz**, sem expor **como ele faz**.

ğŸ“Œ **Exemplo:** Criamos uma classe abstrata `Animal` com o mÃ©todo abstrato `emitirSom()`, que serÃ¡ implementado nas subclasses `Cachorro` e `Gato`.

```java
abstract class Animal {
    abstract void emitirSom();
}

class Cachorro extends Animal {
    @Override
    void emitirSom() {
        System.out.println("O cachorro late: Au Au!");
    }
}

class Gato extends Animal {
    @Override
    void emitirSom() {
        System.out.println("O gato mia: Miau!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal meuCachorro = new Cachorro();
        meuCachorro.emitirSom();

        Animal meuGato = new Gato();
        meuGato.emitirSom();
    }
}
```

ğŸ” **ExplicaÃ§Ã£o:**
- `Animal` Ã© abstrata e define `emitirSom()`, sem implementaÃ§Ã£o.
- `Cachorro` e `Gato` implementam `emitirSom()` de maneira especÃ­fica.
- Criamos objetos que usam polimorfismo para chamar `emitirSom()`.

