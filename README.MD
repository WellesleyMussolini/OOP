# ProgramaÃ§Ã£o Orientada a Objetos (POO) ğŸš€

Este repositÃ³rio Ã© dedicado ao meu aprendizado sobre **ProgramaÃ§Ã£o Orientada a Objetos (POO)**. Aqui, explico de forma simples e intuitiva os principais conceitos da POO com exemplos prÃ¡ticos em **Java**, utilizando apenas **animais de estimaÃ§Ã£o** como exemplo para facilitar o entendimento.

# Classes e Objetos

Em **POO** (ProgramaÃ§Ã£o Orientada a Objetos), classes sÃ£o modelos que definem as caracterÃ­sticas (**estado**) e comportamentos (**mÃ©todos**) de um objeto. Os objetos por sua vez sÃ£o instÃ¢ncias dessas classes, ou seja, representam entidades especÃ­ficas baseadas no modelo definido pela classe.

### O que sÃ£o **estados** e **mÃ©todos** de um objeto?

- **Estado**: Representa os atributos ou dados do objeto. SÃ£o as informaÃ§Ãµes que descrevem o objeto em um determinado momento.
- **MÃ©todos**: Representa as aÃ§Ãµes ou mÃ©todos que o objeto pode executar, definindo como ele interage com outros objetos ou altera seu prÃ³prio estado.

### Analogias para facilitar o entendimento

Pense em uma classe como uma **receita de bolo**. A receita contÃ©m todos os ingredientes e instruÃ§Ãµes necessÃ¡rias para fazer um bolo, mas por si sÃ³ nÃ£o Ã© um bolo real. JÃ¡ o bolo pronto Ã© um **objeto**, ou seja, uma instÃ¢ncia concreta daquela receita.

Outro exemplo: Imagine uma classe **"Animal"**. Essa classe define que todo animal tem um **nome** e uma **idade** (estado) e pode realizar aÃ§Ãµes como **exibir suas informaÃ§Ãµes** (mÃ©todo).

Se tivermos um cachorro chamado **"Rex"**, ele seria um objeto da classe "Animal". Ele tem seu prÃ³prio nome e idade (estado) e pode realizar aÃ§Ãµes definidas na classe, como exibir suas informaÃ§Ãµes (mÃ©todo). Outro cachorro chamado **"Bolt"** seria outro objeto da mesma classe, mas com um estado diferente.

### ğŸ“Œ Exemplo TÃ©cnico:

```java
// DefiniÃ§Ã£o da classe Animal
class Animal {
    String nome; // Estado: nome do animal
    int idade;  // Estado: idade do animal

    // MÃ©todo para exibir informaÃ§Ãµes do animal
    void exibirInformacoes() {
        System.out.println("Nome: " + nome + ", Idade: " + idade + " anos");
    }
}

// Classe principal
public class Main {
    public static void main(String[] args) {
        // Criando um objeto da classe Animal
        Animal pet = new Animal(); // InstÃ¢ncia da classe "Animal"
        
        // Definindo o estado do objeto
        pet.nome = "Rex";
        pet.idade = 3;
        
        // Executando um mÃ©todo do objeto
        pet.exibirInformacoes();
    }
}
```

### ğŸ” ExplicaÃ§Ã£o do CÃ³digo:

1. Criamos a classe `Animal` com dois atributos: `nome` e `idade` (**estado**).
2. Definimos um mÃ©todo `exibirInformacoes()`, que exibe o nome e a idade do animal.
3. No mÃ©todo `main`, instanciamos um objeto `pet` da classe `Animal`.
4. AtribuÃ­mos valores ao estado do objeto (`nome` e `idade`).
5. Chamamos o mÃ©todo `exibirInformacoes()`, que imprime os detalhes do animal.

### ğŸ“Œ SaÃ­da do CÃ³digo:

```
Nome: Rex, Idade: 3 anos
```

Dessa forma, podemos entender claramente que os objetos tÃªm um **estado** (valores especÃ­ficos dos atributos) e um **comportamento** (mÃ©todos que definem suas aÃ§Ãµes).




---
# Encapsulamento

Em **POO** **encapsulamento** Ã© um dos princÃ­pios fundamentais que protege os dados de um objeto, restringindo o acesso direto aos seus atributos e permitindo que sejam manipulados apenas atravÃ©s de mÃ©todos controlados.

Isso ajuda a manter a integridade e seguranÃ§a dos dados, evitando modificaÃ§Ãµes indevidas.

## ğŸ” O que Ã© **Encapsulamento**?

O encapsulamento Ã© a prÃ¡tica de **esconder detalhes internos** de um objeto e fornecer uma interface segura para interaÃ§Ã£o. Isso Ã© feito definindo os atributos como **privados** e fornecendo mÃ©todos pÃºblicos para acessÃ¡-los e modificÃ¡-los (**getters** e **setters**).

### ğŸ“Œ BenefÃ­cios do Encapsulamento:
- Protege os dados de acessos indevidos.
- MantÃ©m a integridade do objeto.
- Facilita a manutenÃ§Ã£o e modificaÃ§Ã£o do cÃ³digo.
- Permite controlar as regras de acesso e modificaÃ§Ã£o dos atributos.

### ğŸ“– Analogias para entender melhor

Imagine um **cofre** onde vocÃª guarda dinheiro. O dinheiro (dado) estÃ¡ protegido dentro do cofre (objeto), e vocÃª sÃ³ pode acessÃ¡-lo usando a chave correta (mÃ©todos). NinguÃ©m pode pegar o dinheiro diretamente sem seguir as regras do cofre.

Outro exemplo: pense em um **controle remoto**. VocÃª pode aumentar ou diminuir o volume da TV pressionando botÃµes (mÃ©todos), mas nÃ£o pode modificar diretamente os circuitos internos da TV (dados protegidos).

Aqui estÃ¡ o texto formatado para o seu README:  

---

### ğŸ“Œ Exemplo TÃ©cnico: Encapsulamento em um Sistema de Controle de Temperatura  

```java
// Classe ControladorDeTemperatura
class ControladorDeTemperatura {
    // Atributo privado (Encapsulamento)
    private double temperatura;

    // Construtor para definir uma temperatura inicial
    public ControladorDeTemperatura(double temperaturaInicial) {
        this.temperatura = temperaturaInicial;
    }

    // MÃ©todo getter para obter a temperatura atual
    public double getTemperatura() {
        return temperatura;
    }

    // MÃ©todo setter para definir a temperatura (com validaÃ§Ã£o)
    public void setTemperatura(double novaTemperatura) {
        if (novaTemperatura >= -50 && novaTemperatura <= 100) {
            this.temperatura = novaTemperatura;
            System.out.println("Temperatura ajustada para: " + novaTemperatura + "Â°C");
        } else {
            System.out.println("Temperatura fora do limite permitido!");
        }
    }
}

// Classe principal para testar o encapsulamento
public class Main {
    public static void main(String[] args) {
        // Criando um objeto da classe ControladorDeTemperatura
        ControladorDeTemperatura sensor = new ControladorDeTemperatura(22.5);
        
        // Consultando a temperatura atual
        System.out.println("Temperatura atual: " + sensor.getTemperatura() + "Â°C");
        
        // Ajustando a temperatura para um valor vÃ¡lido
        sensor.setTemperatura(30.0);
        
        // Tentando definir uma temperatura invÃ¡lida
        sensor.setTemperatura(150.0);
    }
}
```

## ğŸ” ExplicaÃ§Ã£o do CÃ³digo  

1. Criamos a classe `ControladorDeTemperatura` com um atributo **privado** `temperatura`, impedindo acesso direto a ele.  
2. Criamos um **construtor** para definir um valor inicial de temperatura.  
3. Criamos um **getter** (`getTemperatura()`) para permitir a consulta da temperatura.  
4. Criamos um **setter** (`setTemperatura()`) para alterar a temperatura **com uma validaÃ§Ã£o** que impede valores fora do intervalo permitido (-50Â°C a 100Â°C).  
5. No `main`, criamos um objeto `sensor`, consultamos a temperatura, ajustamos para um valor vÃ¡lido e testamos um valor invÃ¡lido.  

## ğŸ“Œ SaÃ­da do CÃ³digo  

```
Temperatura atual: 22.5Â°C  
Temperatura ajustada para: 30.0Â°C  
Temperatura fora do limite permitido!  
```

## ğŸ” O que aprendemos?  

- **O atributo `temperatura` estÃ¡ encapsulado**, protegendo-o de alteraÃ§Ãµes externas indevidas.  
- **O mÃ©todo `setTemperatura()` garante que sÃ³ valores vÃ¡lidos sejam atribuÃ­dos**, evitando falhas no sistema.  
- **O encapsulamento melhora a seguranÃ§a e controle dos dados**, garantindo que apenas operaÃ§Ãµes seguras sejam realizadas.  

---

# ğŸ›ï¸ HeranÃ§a

Em **POO**, a **heranÃ§a** Ã© um princÃ­pio que permite que uma classe (subclasse) herde atributos e mÃ©todos de outra classe (superclasse). Isso promove **reutilizaÃ§Ã£o de cÃ³digo** e facilita a organizaÃ§Ã£o e manutenÃ§Ã£o do sistema.

## ğŸ” O que Ã© **HeranÃ§a**?

A heranÃ§a Ã© um mecanismo que permite a criaÃ§Ã£o de novas classes baseadas em classes existentes. A **classe filha** herda atributos e comportamentos da **classe pai**, podendo reutilizÃ¡-los, modificÃ¡-los ou adicionar novos.

### ğŸ“Œ BenefÃ­cios da HeranÃ§a:
- **ReutilizaÃ§Ã£o de cÃ³digo**: evita duplicaÃ§Ã£o de cÃ³digo, tornando o sistema mais eficiente.
- **Facilita a manutenÃ§Ã£o**: mudanÃ§as na superclasse sÃ£o refletidas nas subclasses.
- **Promove hierarquia e organizaÃ§Ã£o**: classes mais genÃ©ricas servem como base para classes mais especÃ­ficas.
- **Permite polimorfismo**: possibilita que objetos da subclasse sejam tratados como objetos da superclasse.

### ğŸ“– Analogias para entender melhor

Imagine um **carro elÃ©trico**. Ele herda caracterÃ­sticas de um **carro comum** (rodas, volante, portas), mas pode ter novas funcionalidades, como um motor elÃ©trico.

Outro exemplo: pense em uma **Ã¡rvore genealÃ³gica**. Uma pessoa herda caracterÃ­sticas dos seus pais, mas tambÃ©m pode ter atributos Ãºnicos que a diferenciam.

---

### ğŸ“Œ Exemplo TÃ©cnico: HeranÃ§a em um Sistema de Pets  

```java
// Classe base (superclasse)
class Animal {
    protected String nome;
    protected int idade;

    public Animal(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    public void exibirDados() {
        System.out.println("Nome: " + nome);
        System.out.println("Idade: " + idade + " anos");
    }
}

// Classe derivada (subclasse) que herda de Animal
class Cachorro extends Animal {
    private String raca;

    public Cachorro(String nome, int idade, String raca) {
        super(nome, idade); // Chama o construtor da superclasse
        this.raca = raca;
    }

    @Override
    public void exibirDados() {
        super.exibirDados(); // Reutiliza mÃ©todo da superclasse
        System.out.println("RaÃ§a: " + raca);
    }
}

// Classe principal para testar a heranÃ§a
public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal("Bicho", 5);
        Cachorro cachorro = new Cachorro("Rex", 3, "Labrador");

        System.out.println("Dados do Animal:");
        animal.exibirDados();
        
        System.out.println("\nDados do Cachorro:");
        cachorro.exibirDados();
    }
}
```

## ğŸ” ExplicaÃ§Ã£o do CÃ³digo  

1. Criamos a **classe `Animal`** (superclasse), que contÃ©m atributos comuns como `nome` e `idade`.
2. Criamos a **classe `Cachorro`** (subclasse), que **herda** de `Animal` e adiciona um novo atributo `raca`.
3. No **construtor da subclasse**, usamos `super(nome, idade)` para chamar o construtor da superclasse.
4. Sobrescrevemos (`@Override`) o mÃ©todo `exibirDados()` na subclasse para incluir a raÃ§a do cachorro.
5. No `main`, criamos um objeto da superclasse (`Animal`) e um da subclasse (`Cachorro`) e chamamos `exibirDados()` para ambos.

## ğŸ‘‰ SaÃ­da do CÃ³digo  

```
Dados do Animal:
Nome: Bicho
Idade: 5 anos

Dados do Cachorro:
Nome: Rex
Idade: 3 anos
RaÃ§a: Labrador
```

## ğŸ” O que aprendemos?  

- **A classe `Cachorro` herda os atributos e mÃ©todos de `Animal`**, reutilizando cÃ³digo.  
- **A palavra-chave `super` permite acessar mÃ©todos da superclasse** dentro da subclasse.  
- **Podemos sobrescrever mÃ©todos (`@Override`) para personalizar o comportamento da subclasse**.  
- **HeranÃ§a permite criar hierarquias organizadas e reutilizar cÃ³digo eficientemente**. ğŸš€



---


# AbstraÃ§Ã£o  

A **AbstraÃ§Ã£o** Ã© um dos pilares da **ProgramaÃ§Ã£o Orientada a Objetos (POO)** e consiste em **ocultar detalhes de implementaÃ§Ã£o** e **fornecer apenas funcionalidades essenciais**.  

Ela permite que os objetos sejam representados de forma mais genÃ©rica, focando no que Ã© relevante para a aplicaÃ§Ã£o e deixando os detalhes internos escondidos.  

## ğŸ” O que Ã© **AbstraÃ§Ã£o**?  

A abstraÃ§Ã£o permite definir **classes genÃ©ricas** que representam um conceito, sem se preocupar com os detalhes especÃ­ficos de cada implementaÃ§Ã£o.  

Isso Ã© feito por meio de **classes abstratas** e **mÃ©todos abstratos**, que servem como um modelo para outras classes.  

### ğŸ“Œ BenefÃ­cios da AbstraÃ§Ã£o:  

- Reduz a complexidade do cÃ³digo.  
- Facilita a reutilizaÃ§Ã£o e manutenÃ§Ã£o.  
- Separa a lÃ³gica de implementaÃ§Ã£o dos detalhes internos.  
- Permite criar sistemas mais flexÃ­veis e organizados.  

### ğŸ“– Analogias para entender melhor  

Imagine uma **rede social para pets**. VocÃª pode visualizar um perfil, curtir fotos e ver informaÃ§Ãµes bÃ¡sicas, mas **nÃ£o sabe** como os dados sÃ£o armazenados ou processados internamente.  

Outro exemplo: pense em um **controle de videogame**. VocÃª aperta um botÃ£o para pular, mas nÃ£o precisa saber como os circuitos internos processam esse comando.  

---

# ğŸ“Œ Exemplo TÃ©cnico: AbstraÃ§Ã£o em um Sistema de Pets  

```java
// Classe abstrata Pet
abstract class Pet {
    protected String nome;
    protected int idade;

    public Pet(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    // MÃ©todo abstrato (deve ser implementado pelas subclasses)
    public abstract void fazerSom();

    // MÃ©todo concreto (compartilhado por todas as subclasses)
    public void exibirInfo() {
        System.out.println("Nome: " + nome);
        System.out.println("Idade: " + idade + " anos");
    }
}

// Classe Cachorro herda de Pet e implementa o mÃ©todo abstrato
class Cachorro extends Pet {
    public Cachorro(String nome, int idade) {
        super(nome, idade);
    }

    @Override
    public void fazerSom() {
        System.out.println(nome + " diz: Au Au! ğŸ¶");
    }
}

// Classe Gato herda de Pet e implementa o mÃ©todo abstrato
class Gato extends Pet {
    public Gato(String nome, int idade) {
        super(nome, idade);
    }

    @Override
    public void fazerSom() {
        System.out.println(nome + " diz: Miau! ğŸ±");
    }
}

// Classe principal para testar a abstraÃ§Ã£o
public class Main {
    public static void main(String[] args) {
        // Criando objetos das subclasses
        Pet cachorro = new Cachorro("Rex", 5);
        Pet gato = new Gato("Mia", 3);

        // Exibindo informaÃ§Ãµes e sons dos pets
        cachorro.exibirInfo();
        cachorro.fazerSom();

        System.out.println();

        gato.exibirInfo();
        gato.fazerSom();
    }
}
```

---

## ğŸ” ExplicaÃ§Ã£o do CÃ³digo  

1. Criamos uma **classe abstrata `Pet`**, que serve como um modelo para todos os pets.  
2. Definimos um **mÃ©todo abstrato `fazerSom()`**, que **nÃ£o tem implementaÃ§Ã£o na classe `Pet`** e deve ser implementado nas subclasses.  
3. Criamos as classes `Cachorro` e `Gato`, que **herdam de `Pet` e implementam `fazerSom()` com sons diferentes**.  
4. No `main`, criamos objetos de `Cachorro` e `Gato`, chamamos `exibirInfo()` e `fazerSom()` para demonstrar a abstraÃ§Ã£o.  

---

## ğŸ“Œ SaÃ­da do CÃ³digo  

```
Nome: Rex  
Idade: 5 anos  
Rex diz: Au Au! ğŸ¶  

Nome: Mia  
Idade: 3 anos  
Mia diz: Miau! ğŸ±  
```

---

## ğŸ” O que aprendemos?  

- **A classe `Pet` Ã© abstrata**, pois representa um conceito genÃ©rico.  
- **O mÃ©todo `fazerSom()` Ã© abstrato**, forÃ§ando cada pet a ter seu prÃ³prio som.  
- **A abstraÃ§Ã£o permite definir uma estrutura comum** sem precisar detalhar a implementaÃ§Ã£o na superclasse.  
- **Isso torna o cÃ³digo mais organizado, reutilizÃ¡vel e fÃ¡cil de expandir** (podemos adicionar novos pets sem modificar o cÃ³digo existente). ğŸš€  

---

# ğŸ† Polimorfismo  

O **Polimorfismo** Ã© um dos pilares da **ProgramaÃ§Ã£o Orientada a Objetos (POO)** e permite que um mesmo mÃ©todo tenha **diferentes comportamentos** dependendo do objeto que o invoca.  

Isso torna o cÃ³digo mais flexÃ­vel, reutilizÃ¡vel e fÃ¡cil de manter.  

## ğŸ” O que Ã© **Polimorfismo**?  

Polimorfismo significa **"muitas formas"**. Ele permite que um mesmo mÃ©todo seja utilizado por diferentes classes, podendo ser de duas formas:  

1. **Polimorfismo de Sobrescrita (Override)** â€“ Quando uma **subclasse modifica** o comportamento de um mÃ©todo herdado da superclasse.  
2. **Polimorfismo de Sobrecarga (Overload)** â€“ Quando hÃ¡ **mÃ©todos com o mesmo nome**, mas com parÃ¢metros diferentes dentro da mesma classe.  

---

## ğŸ“Œ Exemplo TÃ©cnico: Polimorfismo com Animais  

```java
// Classe base (superclasse)
class Animal {
    public void fazerSom() {
        System.out.println("O animal faz um som.");
    }
}

// Classe derivada (subclasse) - Polimorfismo por Sobrescrita
class Cachorro extends Animal {
    @Override
    public void fazerSom() {
        System.out.println("O cachorro late: Au Au!");
    }
}

// Outra subclasse - Polimorfismo por Sobrescrita
class Gato extends Animal {
    @Override
    public void fazerSom() {
        System.out.println("O gato mia: Miau!");
    }
}

// Classe principal
public class Main {
    public static void main(String[] args) {
        Animal meuAnimal1 = new Cachorro();
        Animal meuAnimal2 = new Gato();

        meuAnimal1.fazerSom(); // SaÃ­da: O cachorro late: Au Au!
        meuAnimal2.fazerSom(); // SaÃ­da: O gato mia: Miau!
    }
}
```

## ğŸ“Œ SaÃ­da do CÃ³digo  

```
O cachorro late: Au Au!  
O gato mia: Miau!  
```

### âœ… O que aprendemos?  

âœ” **A classe `Animal` define um mÃ©todo genÃ©rico `fazerSom()`.**  
âœ” **As subclasses `Cachorro` e `Gato` sobrescrevem esse mÃ©todo com seu prÃ³prio comportamento.**  
âœ” **Isso permite que possamos chamar `fazerSom()` em qualquer `Animal`, sem precisar saber qual tipo especÃ­fico ele Ã©.**  

---

# ğŸ­ Interfaces  

As **interfaces** sÃ£o contratos que definem **quais mÃ©todos** uma classe deve implementar, sem fornecer uma implementaÃ§Ã£o concreta.  

Isso ajuda a garantir que diferentes classes sigam um **padrÃ£o comum**, promovendo reutilizaÃ§Ã£o e flexibilidade no cÃ³digo.  

## ğŸ” O que Ã© uma **Interface**?  

Uma interface contÃ©m **apenas a assinatura dos mÃ©todos**, sem definir como eles devem ser implementados.  

As classes que **"assinam o contrato"** (implementam a interface) **devem fornecer suas prÃ³prias implementaÃ§Ãµes**.  

---

## ğŸ“Œ Exemplo TÃ©cnico: Interface para Animais  

```java
// DefiniÃ§Ã£o da interface
interface Animal {
    void fazerSom(); // MÃ©todo sem implementaÃ§Ã£o (obrigatÃ³rio nas classes que implementam)
}

// Classe Cachorro implementa a interface Animal
class Cachorro implements Animal {
    @Override
    public void fazerSom() {
        System.out.println("O cachorro late: Au Au!");
    }
}

// Classe Gato implementa a interface Animal
class Gato implements Animal {
    @Override
    public void fazerSom() {
        System.out.println("O gato mia: Miau!");
    }
}

// Classe principal
public class Main {
    public static void main(String[] args) {
        Animal meuAnimal1 = new Cachorro();
        Animal meuAnimal2 = new Gato();

        meuAnimal1.fazerSom(); // SaÃ­da: O cachorro late: Au Au!
        meuAnimal2.fazerSom(); // SaÃ­da: O gato mia: Miau!
    }
}
```

## ğŸ“Œ SaÃ­da do CÃ³digo  

```
O cachorro late: Au Au!  
O gato mia: Miau!  
```

### âœ… O que aprendemos?  

âœ” **A interface `Animal` define um contrato com o mÃ©todo `fazerSom()`.**  
âœ” **As classes `Cachorro` e `Gato` sÃ£o obrigadas a implementar esse mÃ©todo.**  
âœ” **Podemos usar `Animal` como um tipo genÃ©rico, permitindo um cÃ³digo mais flexÃ­vel.**  

---

## ğŸš€ ConclusÃ£o  

- **Polimorfismo** permite que um mÃ©todo tenha **diferentes comportamentos** dependendo da classe.  
- **Interfaces** ajudam a padronizar mÃ©todos sem definir a implementaÃ§Ã£o, garantindo que diferentes classes sigam um contrato comum.  
- Ambos melhoram a **organizaÃ§Ã£o, flexibilidade e reutilizaÃ§Ã£o do cÃ³digo**! ğŸ¯  

