# ProgramaÃ§Ã£o Orientada a Objetos (POO)

Este repositÃ³rio reÃºne conceitos fundamentais da **ProgramaÃ§Ã£o Orientada a Objetos (POO)**, apresentados de forma simples e intuitiva com exemplos prÃ¡ticos em **Java**. Para facilitar o entendimento.

## SumÃ¡rio

1. [Classes e Objetos](#classes-e-objetos)
2. [Encapsulamento](#encapsulamento)
3. [HeranÃ§a](#heranÃ§a)
4. [AbstraÃ§Ã£o](#abstraÃ§Ã£o)
5. [Polimorfismo](#polimorfismo)
6. [Interfaces](#interfaces)
7. [ConclusÃ£o](#conclusÃ£o)

---

## 1. Classes e Objetos

Em **POO**, **classes** sÃ£o modelos que definem as caracterÃ­sticas (**estado**) e os comportamentos (**mÃ©todos**) de um objeto. Um **objeto** Ã© uma instÃ¢ncia de uma classe, ou seja, uma ocorrÃªncia especÃ­fica que possui os atributos e comportamentos definidos na classe.

### Conceitos BÃ¡sicos

- **Estado**: Conjunto de atributos (dados) que descrevem o objeto em um determinado momento.
- **MÃ©todos**: Conjunto de aÃ§Ãµes (funÃ§Ãµes) que o objeto pode executar para interagir ou alterar seu estado.

### Analogias

- **Receita de Bolo**: A classe Ã© a receita, que contÃ©m os ingredientes (atributos) e o modo de preparo (mÃ©todos). O bolo assado Ã© o objeto, ou seja, uma instÃ¢ncia real da receita.
- **Animal**: Imagine uma classe `Animal` que define que todo animal tem um nome e uma idade. Um cachorro chamado "Rex" Ã© um objeto dessa classe, possuindo seus prÃ³prios valores para os atributos.

### Exemplo PrÃ¡tico

```java
// DefiniÃ§Ã£o da classe Animal
class Animal {
    String nome; // Estado: nome do animal
    int idade;   // Estado: idade do animal

    // MÃ©todo: exibe informaÃ§Ãµes do animal
    void exibirInformacoes() {
        System.out.println("Nome: " + nome + ", Idade: " + idade + " anos");
    }
}

// Classe principal para testar a classe Animal
public class Main {
    public static void main(String[] args) {
        Animal pet = new Animal(); // CriaÃ§Ã£o do objeto (instÃ¢ncia da classe Animal)
        pet.nome = "Rex";          // Definindo o estado do objeto
        pet.idade = 3;
        
        pet.exibirInformacoes();   // Executando um mÃ©todo (comportamento)
    }
}
```

**SaÃ­da do CÃ³digo:**
```
Nome: Rex, Idade: 3 anos
```

---

## 2. Encapsulamento

O **encapsulamento** Ã© o princÃ­pio que protege os dados internos de um objeto, restringindo o acesso direto aos seus atributos e permitindo manipulaÃ§Ãµes somente por meio de mÃ©todos controlados (getters e setters). Isso mantÃ©m a integridade e a seguranÃ§a dos dados.

### BenefÃ­cios

- Protege os dados de acessos indevidos.
- Facilita a manutenÃ§Ã£o e a modificaÃ§Ã£o do cÃ³digo.
- Permite controlar as regras de acesso e modificaÃ§Ã£o dos atributos.

### Analogia

Imagine um **cofre**: o dinheiro estÃ¡ protegido e sÃ³ pode ser acessado com a chave certa (mÃ©todos), evitando que qualquer um acesse diretamente o conteÃºdo.

### Exemplo PrÃ¡tico

```java
// Classe que exemplifica o encapsulamento
class ControladorDeTemperatura {
    // Atributo privado, nÃ£o acessÃ­vel diretamente
    private double temperatura;

    // Construtor que define uma temperatura inicial
    public ControladorDeTemperatura(double temperaturaInicial) {
        this.temperatura = temperaturaInicial;
    }

    // Getter para consultar a temperatura
    public double getTemperatura() {
        return temperatura;
    }

    // Setter para alterar a temperatura, com validaÃ§Ã£o
    public void setTemperatura(double novaTemperatura) {
        if (novaTemperatura >= -50 && novaTemperatura <= 100) {
            this.temperatura = novaTemperatura;
            System.out.println("Temperatura ajustada para: " + novaTemperatura + "Â°C");
        } else {
            System.out.println("Temperatura fora do limite permitido!");
        }
    }
}

// Classe principal para testar o encapsulamento
public class Main {
    public static void main(String[] args) {
        ControladorDeTemperatura sensor = new ControladorDeTemperatura(22.5);
        System.out.println("Temperatura atual: " + sensor.getTemperatura() + "Â°C");
        sensor.setTemperatura(30.0);  // Valor vÃ¡lido
        sensor.setTemperatura(150.0); // Valor invÃ¡lido
    }
}
```

**SaÃ­da do CÃ³digo:**
```
Temperatura atual: 22.5Â°C  
Temperatura ajustada para: 30.0Â°C  
Temperatura fora do limite permitido!
```

---

## 3. HeranÃ§a

A **heranÃ§a** permite que uma classe (subclasse) herde atributos e mÃ©todos de outra classe (superclasse), promovendo a reutilizaÃ§Ã£o de cÃ³digo e a organizaÃ§Ã£o hierÃ¡rquica.

### BenefÃ­cios

- Evita duplicaÃ§Ã£o de cÃ³digo.
- Facilita a manutenÃ§Ã£o, pois alteraÃ§Ãµes na superclasse sÃ£o refletidas nas subclasses.
- Permite a criaÃ§Ã£o de hierarquias organizadas.

### Exemplo PrÃ¡tico

```java
// Superclasse Animal
class Animal {
    protected String nome;
    protected int idade;

    public Animal(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    public void exibirDados() {
        System.out.println("Nome: " + nome);
        System.out.println("Idade: " + idade + " anos");
    }
}

// Subclasse Cachorro que herda de Animal
class Cachorro extends Animal {
    private String raca;

    public Cachorro(String nome, int idade, String raca) {
        super(nome, idade); // Invoca o construtor da superclasse
        this.raca = raca;
    }

    @Override
    public void exibirDados() {
        super.exibirDados(); // Reaproveita o mÃ©todo da superclasse
        System.out.println("RaÃ§a: " + raca);
    }
}

// Classe principal para testar a heranÃ§a
public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal("Bicho", 5);
        Cachorro cachorro = new Cachorro("Rex", 3, "Labrador");

        System.out.println("Dados do Animal:");
        animal.exibirDados();
        
        System.out.println("\nDados do Cachorro:");
        cachorro.exibirDados();
    }
}
```

**SaÃ­da do CÃ³digo:**
```
Dados do Animal:
Nome: Bicho
Idade: 5 anos

Dados do Cachorro:
Nome: Rex
Idade: 3 anos
RaÃ§a: Labrador
```

---

## 4. AbstraÃ§Ã£o

A **abstraÃ§Ã£o** consiste em ocultar detalhes de implementaÃ§Ã£o e fornecer somente as funcionalidades essenciais. Isso permite definir classes e mÃ©todos que servem de modelo, sem precisar especificar todos os detalhes.

### BenefÃ­cios

- Reduz a complexidade do cÃ³digo.
- Separa a lÃ³gica de implementaÃ§Ã£o dos detalhes internos.
- Facilita a manutenÃ§Ã£o e a expansÃ£o do sistema.

### Exemplo PrÃ¡tico

```java
// Classe abstrata que serve como modelo para pets
abstract class Pet {
    protected String nome;
    protected int idade;

    public Pet(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    // MÃ©todo abstrato: nÃ£o possui implementaÃ§Ã£o na classe Pet
    public abstract void fazerSom();

    // MÃ©todo concreto: implementado na classe abstrata e herdado pelas subclasses
    public void exibirInfo() {
        System.out.println("Nome: " + nome);
        System.out.println("Idade: " + idade + " anos");
    }
}

// Subclasse Cachorro que implementa o mÃ©todo abstrato
class Cachorro extends Pet {
    public Cachorro(String nome, int idade) {
        super(nome, idade);
    }

    @Override
    public void fazerSom() {
        System.out.println(nome + " diz: Au Au! ğŸ¶");
    }
}

// Subclasse Gato que implementa o mÃ©todo abstrato
class Gato extends Pet {
    public Gato(String nome, int idade) {
        super(nome, idade);
    }

    @Override
    public void fazerSom() {
        System.out.println(nome + " diz: Miau! ğŸ±");
    }
}

// Classe principal para testar a abstraÃ§Ã£o
public class Main {
    public static void main(String[] args) {
        Pet cachorro = new Cachorro("Rex", 5);
        Pet gato = new Gato("Mia", 3);

        cachorro.exibirInfo();
        cachorro.fazerSom();

        System.out.println();

        gato.exibirInfo();
        gato.fazerSom();
    }
}
```

**SaÃ­da do CÃ³digo:**
```
Nome: Rex  
Idade: 5 anos  
Rex diz: Au Au! ğŸ¶  

Nome: Mia  
Idade: 3 anos  
Mia diz: Miau! ğŸ±
```

---

## 5. Polimorfismo

O **polimorfismo** permite que mÃ©todos com o mesmo nome tenham comportamentos diferentes, dependendo do objeto que os invoca. Essa caracterÃ­stica torna o cÃ³digo mais flexÃ­vel e extensÃ­vel.

### Tipos de Polimorfismo

1. **Sobrescrita (Override):** Uma subclasse redefine o comportamento de um mÃ©todo herdado da superclasse.  
2. **Sobrecarga (Overload):** MÃ©todos com o mesmo nome, mas com diferentes parÃ¢metros, dentro de uma mesma classe.

### Exemplo PrÃ¡tico (Sobrescrita)

```java
// Superclasse Animal
class Animal {
    public void fazerSom() {
        System.out.println("O animal faz um som.");
    }
}

// Subclasse Cachorro sobrescrevendo o mÃ©todo
class Cachorro extends Animal {
    @Override
    public void fazerSom() {
        System.out.println("O cachorro late: Au Au!");
    }
}

// Subclasse Gato sobrescrevendo o mÃ©todo
class Gato extends Animal {
    @Override
    public void fazerSom() {
        System.out.println("O gato mia: Miau!");
    }
}

// Classe principal para testar o polimorfismo
public class Main {
    public static void main(String[] args) {
        Animal meuAnimal1 = new Cachorro();
        Animal meuAnimal2 = new Gato();

        meuAnimal1.fazerSom(); // SaÃ­da: O cachorro late: Au Au!
        meuAnimal2.fazerSom(); // SaÃ­da: O gato mia: Miau!
    }
}
```

**SaÃ­da do CÃ³digo:**
```
O cachorro late: Au Au!
O gato mia: Miau!
```

---

## 6. Interfaces

**Interfaces** sÃ£o contratos que definem quais mÃ©todos uma classe deve implementar, sem fornecer uma implementaÃ§Ã£o concreta. Elas garantem que diferentes classes sigam um padrÃ£o comum.

### BenefÃ­cios

- Padronizam a comunicaÃ§Ã£o entre classes.
- Permitem que classes nÃ£o relacionadas implementem os mesmos mÃ©todos, facilitando a interoperabilidade.
- Promovem a flexibilidade e a reutilizaÃ§Ã£o do cÃ³digo.

### Exemplo PrÃ¡tico

```java
// DefiniÃ§Ã£o da interface Animal
interface Animal {
    void fazerSom(); // MÃ©todo sem implementaÃ§Ã£o
}

// Classe Cachorro implementa a interface Animal
class Cachorro implements Animal {
    @Override
    public void fazerSom() {
        System.out.println("O cachorro late: Au Au!");
    }
}

// Classe Gato implementa a interface Animal
class Gato implements Animal {
    @Override
    public void fazerSom() {
        System.out.println("O gato mia: Miau!");
    }
}

// Classe principal para testar a interface
public class Main {
    public static void main(String[] args) {
        Animal meuAnimal1 = new Cachorro();
        Animal meuAnimal2 = new Gato();

        meuAnimal1.fazerSom(); // SaÃ­da: O cachorro late: Au Au!
        meuAnimal2.fazerSom(); // SaÃ­da: O gato mia: Miau!
    }
}
```

**SaÃ­da do CÃ³digo:**
```
O cachorro late: Au Au!
O gato mia: Miau!
```

---

## 7. Resumo

- **Classes e Objetos:** Definem os modelos (classes) e suas instÃ¢ncias (objetos) com estados e comportamentos.  
- **Encapsulamento:** Protege os dados internos, permitindo o acesso seguro por meio de mÃ©todos.  
- **HeranÃ§a:** Permite a criaÃ§Ã£o de hierarquias e a reutilizaÃ§Ã£o de cÃ³digo entre classes relacionadas.  
- **AbstraÃ§Ã£o:** Oculta os detalhes de implementaÃ§Ã£o, focando nas funcionalidades essenciais.  
- **Polimorfismo:** Permite mÃ©todos com o mesmo nome se comportarem de maneira diferente, conforme o objeto que os invoca.  
- **Interfaces:** Estabelecem contratos que garantem a implementaÃ§Ã£o de mÃ©todos padronizados, promovendo flexibilidade.

